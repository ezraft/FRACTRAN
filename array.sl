10319933344096124839345489713523872358335209711489169202745383828356302535306650415480575667951367803800846015169733003069990448342956396604220411589713237534184229886069844359831026727272720981432465176309850485116345596274854487766917160430646877764291262698472397639092480673174060576202768596905779772280264061236383427939789181913287059800139453657493771463498618689373365249893106356504173555335721939745240814485793228173928148784549596269557528122909502106863815631142931306901157668188040345514372725697093909164506107868584123851532582588381618218094134311357403015238102970056219258831154628797734546355011683729504795372124616796488252531734828948100439891887089029758357647027883443470013503716698343907139324103459012768744581239697023128682259515977354845013463509882769556107140548383479330516236020733840506613278342681489885495189046381903990907671820936499271248842302347702064476234719428608
# input array: [15, 12, 11]
# rework of the stack to support 4-bit values (in theory this could change but will be similar)
# note: this is intended to show exponential growth in operations when dealing with polynomial calculations
# program function: access and return the first element of the array (0-indexed), without changing the contents
# specification: the array will be stored in register 2
# the result will be stored in register 3
# the array will be preserved in register 2

# quick copy array (linear time in number of elements) from 2 into 7 and 11 [4 lines]
1235736291547681/256 1,1/1 2
35153041/16 2,1/1 3
5929/4 3,1/1 4
77/2 4,1/1 5

# fast swap 11 into 2, placing array back in its place [4 lines]
256/214358881 5,1/1 6
16/14641 6,1/1 7
4/121 7,1/1 8
2/11 8,1/1 9

# pop and place result in register 3 [4 lines]
6561/5764801 10,1/1 10
81/2401 11,1/1 11
9/49 12,1/1 12
3/7 13,1/1 13

# clear register 7 [ lines]
1/1219760487635835700138573862562971820755615294131238401 13,1/1 14
1/1104427674243920646305299201 14,1/1 15
1/33232930569601 15,1/1 16
1/5764801 16,1/1 17
1/2401 17,1/1 18
1/49 18,1/1 19
1/7 19